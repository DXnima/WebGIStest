{"version":3,"sources":["webpack:///./node_modules/ol/interaction/draweventtype.js","webpack:///./node_modules/ol/interaction/draw.js","webpack:///./node_modules/ol/geom/circle.js"],"names":["_ol_interaction_DrawEventType_","DRAWSTART","DRAWEND","_ol_interaction_Draw_","options","call","this","handleDownEvent","handleDownEvent_","handleEvent","handleUpEvent","handleUpEvent_","shouldHandle_","downPx_","freehand_","source_","source","features_","features","snapTolerance_","snapTolerance","type_","mode_","getMode_","stopClick_","stopClick","minPoints_","minPoints","Mode_","POLYGON","maxPoints_","maxPoints","Infinity","finishCondition_","finishCondition","TRUE","geometryFunction","CIRCLE","coordinates","opt_geometry","circle","NaN","squaredLength","squaredDistance","setCenterAndRadius","Math","sqrt","Constructor","mode","POINT","LINE_STRING","geometry","length","setCoordinates","concat","geometryFunction_","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","useSpatialIndex","wrapX","style","getDefaultStyleFunction","geometryName_","geometryName","condition_","condition","noModifierKeys","freehandCondition_","freehand","always","freehandCondition","shiftKeyOnly","listen","getChangeEventType","ACTIVE","updateState_","inherits","styles","createDefaultEditing","feature","resolution","getGeometry","getType","prototype","setMap","map","event","pass","type","POINTERDRAG","addToDrawing_","POINTERDOWN","POINTERMOVE","handlePointerMove_","DBLCLICK","pixel","startDrawing_","circleMode","finishDrawing","atFinish_","abortDrawing_","stopPropagation","downPx","clickPx","dx","dy","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","i","ii","finishCoordinate","finishPixel","getPixelFromCoordinate","coordinate","slice","sketchPointGeom","updateSketchFeatures_","start","setGeometryName","setGeometry","dispatchEvent","Event","last","sketchLineGeom","ring","getLinearRing","setFlatCoordinates","getLayout","getFlatCoordinates","done","pop","push","removeLastPoint","splice","sketchFeature","getCoordinates","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","addFeature","getSource","clear","extend","lineString","shouldStopEvent","FALSE","sketchFeatures","overlaySource","addFeatures","getMap","active","getActive","createRegularPolygon","opt_sides","opt_angle","center","end","radius","fromCircle","angle","atan","makeRegular","createBox","extent","boundingExtent","getBottomLeft","getBottomRight","getTopRight","getTopLeft","_ol_geom_Circle_","opt_radius","opt_layout","clone","layout","flatCoordinates","closestPointXY","x","y","closestPoint","minSquaredDistance","stride","delta","getRadius","containsXY","getRadiusSquared_","getCenter","computeExtent","createOrUpdate","intersectsExtent","circleExtent","getExtent","intersects","forEachCorner","intersectsCoordinate","setCenter","setLayout","offset","changed","XY","setFlatCoordinatesInternal","setRadius","transform"],"mappings":"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","file":"js/chunk-5e56ac5c.d247204d.js","sourcesContent":["/**\n * @enum {string}\n */\nvar _ol_interaction_DrawEventType_ = {\n  /**\n   * Triggered upon feature draw start\n   * @event ol.interaction.Draw.Event#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event ol.interaction.Draw.Event#drawend\n   * @api\n   */\n  DRAWEND: 'drawend'\n};\n\nexport default _ol_interaction_DrawEventType_;\n","import _ol_ from '../index.js';\nimport _ol_Feature_ from '../feature.js';\nimport _ol_MapBrowserEventType_ from '../mapbrowsereventtype.js';\nimport _ol_Object_ from '../object.js';\nimport _ol_coordinate_ from '../coordinate.js';\nimport _ol_events_ from '../events.js';\nimport _ol_events_Event_ from '../events/event.js';\nimport _ol_events_condition_ from '../events/condition.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_functions_ from '../functions.js';\nimport _ol_geom_Circle_ from '../geom/circle.js';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype.js';\nimport _ol_geom_LineString_ from '../geom/linestring.js';\nimport _ol_geom_MultiLineString_ from '../geom/multilinestring.js';\nimport _ol_geom_MultiPoint_ from '../geom/multipoint.js';\nimport _ol_geom_MultiPolygon_ from '../geom/multipolygon.js';\nimport _ol_geom_Point_ from '../geom/point.js';\nimport _ol_geom_Polygon_ from '../geom/polygon.js';\nimport _ol_interaction_DrawEventType_ from '../interaction/draweventtype.js';\nimport _ol_interaction_Pointer_ from '../interaction/pointer.js';\nimport _ol_interaction_Property_ from '../interaction/property.js';\nimport _ol_layer_Vector_ from '../layer/vector.js';\nimport _ol_source_Vector_ from '../source/vector.js';\nimport _ol_style_Style_ from '../style/style.js';\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @constructor\n * @extends {ol.interaction.Pointer}\n * @fires ol.interaction.Draw.Event\n * @param {olx.interaction.DrawOptions} options Options.\n * @api\n */\nvar _ol_interaction_Draw_ = function(options) {\n\n  _ol_interaction_Pointer_.call(this, {\n    handleDownEvent: _ol_interaction_Draw_.handleDownEvent_,\n    handleEvent: _ol_interaction_Draw_.handleEvent,\n    handleUpEvent: _ol_interaction_Draw_.handleUpEvent_\n  });\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.shouldHandle_ = false;\n\n  /**\n   * @type {ol.Pixel}\n   * @private\n   */\n  this.downPx_ = null;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.freehand_ = false;\n\n  /**\n   * Target source for drawn features.\n   * @type {ol.source.Vector}\n   * @private\n   */\n  this.source_ = options.source ? options.source : null;\n\n  /**\n   * Target collection for drawn features.\n   * @type {ol.Collection.<ol.Feature>}\n   * @private\n   */\n  this.features_ = options.features ? options.features : null;\n\n  /**\n   * Pixel distance for snapping.\n   * @type {number}\n   * @private\n   */\n  this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n  /**\n   * Geometry type.\n   * @type {ol.geom.GeometryType}\n   * @private\n   */\n  this.type_ = /** @type {ol.geom.GeometryType} */ (options.type);\n\n  /**\n   * Drawing mode (derived from geometry type.\n   * @type {ol.interaction.Draw.Mode_}\n   * @private\n   */\n  this.mode_ = _ol_interaction_Draw_.getMode_(this.type_);\n\n  /**\n   * Stop click, singleclick, and doubleclick events from firing during drawing.\n   * Default is `false`.\n   * @type {boolean}\n   * @private\n   */\n  this.stopClick_ = !!options.stopClick;\n\n  /**\n   * The number of points that must be drawn before a polygon ring or line\n   * string can be finished.  The default is 3 for polygon rings and 2 for\n   * line strings.\n   * @type {number}\n   * @private\n   */\n  this.minPoints_ = options.minPoints ?\n    options.minPoints :\n    (this.mode_ === _ol_interaction_Draw_.Mode_.POLYGON ? 3 : 2);\n\n  /**\n   * The number of points that can be drawn before a polygon ring or line string\n   * is finished. The default is no restriction.\n   * @type {number}\n   * @private\n   */\n  this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;\n\n  /**\n   * A function to decide if a potential finish coordinate is permissible\n   * @private\n   * @type {ol.EventsConditionType}\n   */\n  this.finishCondition_ = options.finishCondition ? options.finishCondition : _ol_functions_.TRUE;\n\n  var geometryFunction = options.geometryFunction;\n  if (!geometryFunction) {\n    if (this.type_ === _ol_geom_GeometryType_.CIRCLE) {\n      /**\n       * @param {!Array.<ol.Coordinate>} coordinates\n       *     The coordinates.\n       * @param {ol.geom.SimpleGeometry=} opt_geometry Optional geometry.\n       * @return {ol.geom.SimpleGeometry} A geometry.\n       */\n      geometryFunction = function(coordinates, opt_geometry) {\n        var circle = opt_geometry ? /** @type {ol.geom.Circle} */ (opt_geometry) :\n          new _ol_geom_Circle_([NaN, NaN]);\n        var squaredLength = _ol_coordinate_.squaredDistance(\n            coordinates[0], coordinates[1]);\n        circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));\n        return circle;\n      };\n    } else {\n      var Constructor;\n      var mode = this.mode_;\n      if (mode === _ol_interaction_Draw_.Mode_.POINT) {\n        Constructor = _ol_geom_Point_;\n      } else if (mode === _ol_interaction_Draw_.Mode_.LINE_STRING) {\n        Constructor = _ol_geom_LineString_;\n      } else if (mode === _ol_interaction_Draw_.Mode_.POLYGON) {\n        Constructor = _ol_geom_Polygon_;\n      }\n      /**\n       * @param {!Array.<ol.Coordinate>} coordinates\n       *     The coordinates.\n       * @param {ol.geom.SimpleGeometry=} opt_geometry Optional geometry.\n       * @return {ol.geom.SimpleGeometry} A geometry.\n       */\n      geometryFunction = function(coordinates, opt_geometry) {\n        var geometry = opt_geometry;\n        if (geometry) {\n          if (mode === _ol_interaction_Draw_.Mode_.POLYGON) {\n            if (coordinates[0].length) {\n              // Add a closing coordinate to match the first\n              geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\n            } else {\n              geometry.setCoordinates([]);\n            }\n          } else {\n            geometry.setCoordinates(coordinates);\n          }\n        } else {\n          geometry = new Constructor(coordinates);\n        }\n        return geometry;\n      };\n    }\n  }\n\n  /**\n   * @type {ol.DrawGeometryFunctionType}\n   * @private\n   */\n  this.geometryFunction_ = geometryFunction;\n\n  /**\n   * Finish coordinate for the feature (first point for polygons, last point for\n   * linestrings).\n   * @type {ol.Coordinate}\n   * @private\n   */\n  this.finishCoordinate_ = null;\n\n  /**\n   * Sketch feature.\n   * @type {ol.Feature}\n   * @private\n   */\n  this.sketchFeature_ = null;\n\n  /**\n   * Sketch point.\n   * @type {ol.Feature}\n   * @private\n   */\n  this.sketchPoint_ = null;\n\n  /**\n   * Sketch coordinates. Used when drawing a line or polygon.\n   * @type {ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>}\n   * @private\n   */\n  this.sketchCoords_ = null;\n\n  /**\n   * Sketch line. Used when drawing polygon.\n   * @type {ol.Feature}\n   * @private\n   */\n  this.sketchLine_ = null;\n\n  /**\n   * Sketch line coordinates. Used when drawing a polygon or circle.\n   * @type {Array.<ol.Coordinate>}\n   * @private\n   */\n  this.sketchLineCoords_ = null;\n\n  /**\n   * Squared tolerance for handling up events.  If the squared distance\n   * between a down and up event is greater than this tolerance, up events\n   * will not be handled.\n   * @type {number}\n   * @private\n   */\n  this.squaredClickTolerance_ = options.clickTolerance ?\n    options.clickTolerance * options.clickTolerance : 36;\n\n  /**\n   * Draw overlay where our sketch features are drawn.\n   * @type {ol.layer.Vector}\n   * @private\n   */\n  this.overlay_ = new _ol_layer_Vector_({\n    source: new _ol_source_Vector_({\n      useSpatialIndex: false,\n      wrapX: options.wrapX ? options.wrapX : false\n    }),\n    style: options.style ? options.style :\n      _ol_interaction_Draw_.getDefaultStyleFunction()\n  });\n\n  /**\n   * Name of the geometry attribute for newly created features.\n   * @type {string|undefined}\n   * @private\n   */\n  this.geometryName_ = options.geometryName;\n\n  /**\n   * @private\n   * @type {ol.EventsConditionType}\n   */\n  this.condition_ = options.condition ?\n    options.condition : _ol_events_condition_.noModifierKeys;\n\n  /**\n   * @private\n   * @type {ol.EventsConditionType}\n   */\n  this.freehandCondition_;\n  if (options.freehand) {\n    this.freehandCondition_ = _ol_events_condition_.always;\n  } else {\n    this.freehandCondition_ = options.freehandCondition ?\n      options.freehandCondition : _ol_events_condition_.shiftKeyOnly;\n  }\n\n  _ol_events_.listen(this,\n      _ol_Object_.getChangeEventType(_ol_interaction_Property_.ACTIVE),\n      this.updateState_, this);\n\n};\n\n_ol_.inherits(_ol_interaction_Draw_, _ol_interaction_Pointer_);\n\n\n/**\n * @return {ol.StyleFunction} Styles.\n */\n_ol_interaction_Draw_.getDefaultStyleFunction = function() {\n  var styles = _ol_style_Style_.createDefaultEditing();\n  return function(feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_interaction_Draw_.prototype.setMap = function(map) {\n  _ol_interaction_Pointer_.prototype.setMap.call(this, map);\n  this.updateState_();\n};\n\n\n/**\n * Handles the {@link ol.MapBrowserEvent map browser event} and may actually\n * draw or finish the drawing.\n * @param {ol.MapBrowserEvent} event Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {ol.interaction.Draw}\n * @api\n */\n_ol_interaction_Draw_.handleEvent = function(event) {\n  this.freehand_ = this.mode_ !== _ol_interaction_Draw_.Mode_.POINT && this.freehandCondition_(event);\n  var pass = true;\n  if (this.freehand_ &&\n      event.type === _ol_MapBrowserEventType_.POINTERDRAG &&\n      this.sketchFeature_ !== null) {\n    this.addToDrawing_(event);\n    pass = false;\n  } else if (this.freehand_ &&\n      event.type === _ol_MapBrowserEventType_.POINTERDOWN) {\n    pass = false;\n  } else if (event.type === _ol_MapBrowserEventType_.POINTERMOVE) {\n    pass = this.handlePointerMove_(event);\n  } else if (event.type === _ol_MapBrowserEventType_.DBLCLICK) {\n    pass = false;\n  }\n  return _ol_interaction_Pointer_.handleEvent.call(this, event) && pass;\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} event Event.\n * @return {boolean} Start drag sequence?\n * @this {ol.interaction.Draw}\n * @private\n */\n_ol_interaction_Draw_.handleDownEvent_ = function(event) {\n  this.shouldHandle_ = !this.freehand_;\n\n  if (this.freehand_) {\n    this.downPx_ = event.pixel;\n    if (!this.finishCoordinate_) {\n      this.startDrawing_(event);\n    }\n    return true;\n  } else if (this.condition_(event)) {\n    this.downPx_ = event.pixel;\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} event Event.\n * @return {boolean} Stop drag sequence?\n * @this {ol.interaction.Draw}\n * @private\n */\n_ol_interaction_Draw_.handleUpEvent_ = function(event) {\n  var pass = true;\n\n  this.handlePointerMove_(event);\n\n  var circleMode = this.mode_ === _ol_interaction_Draw_.Mode_.CIRCLE;\n\n  if (this.shouldHandle_) {\n    if (!this.finishCoordinate_) {\n      this.startDrawing_(event);\n      if (this.mode_ === _ol_interaction_Draw_.Mode_.POINT) {\n        this.finishDrawing();\n      }\n    } else if (this.freehand_ || circleMode) {\n      this.finishDrawing();\n    } else if (this.atFinish_(event)) {\n      if (this.finishCondition_(event)) {\n        this.finishDrawing();\n      }\n    } else {\n      this.addToDrawing_(event);\n    }\n    pass = false;\n  } else if (this.freehand_) {\n    this.finishCoordinate_ = null;\n    this.abortDrawing_();\n  }\n  if (!pass && this.stopClick_) {\n    event.stopPropagation();\n  }\n  return pass;\n};\n\n\n/**\n * Handle move events.\n * @param {ol.MapBrowserEvent} event A move event.\n * @return {boolean} Pass the event to other interactions.\n * @private\n */\n_ol_interaction_Draw_.prototype.handlePointerMove_ = function(event) {\n  if (this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n      (this.freehand_ && !this.shouldHandle_))) {\n    var downPx = this.downPx_;\n    var clickPx = event.pixel;\n    var dx = downPx[0] - clickPx[0];\n    var dy = downPx[1] - clickPx[1];\n    var squaredDistance = dx * dx + dy * dy;\n    this.shouldHandle_ = this.freehand_ ?\n      squaredDistance > this.squaredClickTolerance_ :\n      squaredDistance <= this.squaredClickTolerance_;\n  }\n\n  if (this.finishCoordinate_) {\n    this.modifyDrawing_(event);\n  } else {\n    this.createOrUpdateSketchPoint_(event);\n  }\n  return true;\n};\n\n\n/**\n * Determine if an event is within the snapping tolerance of the start coord.\n * @param {ol.MapBrowserEvent} event Event.\n * @return {boolean} The event is within the snapping tolerance of the start.\n * @private\n */\n_ol_interaction_Draw_.prototype.atFinish_ = function(event) {\n  var at = false;\n  if (this.sketchFeature_) {\n    var potentiallyDone = false;\n    var potentiallyFinishCoordinates = [this.finishCoordinate_];\n    if (this.mode_ === _ol_interaction_Draw_.Mode_.LINE_STRING) {\n      potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n    } else if (this.mode_ === _ol_interaction_Draw_.Mode_.POLYGON) {\n      potentiallyDone = this.sketchCoords_[0].length >\n          this.minPoints_;\n      potentiallyFinishCoordinates = [this.sketchCoords_[0][0],\n        this.sketchCoords_[0][this.sketchCoords_[0].length - 2]];\n    }\n    if (potentiallyDone) {\n      var map = event.map;\n      for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n        var finishCoordinate = potentiallyFinishCoordinates[i];\n        var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n        var pixel = event.pixel;\n        var dx = pixel[0] - finishPixel[0];\n        var dy = pixel[1] - finishPixel[1];\n        var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n        at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n        if (at) {\n          this.finishCoordinate_ = finishCoordinate;\n          break;\n        }\n      }\n    }\n  }\n  return at;\n};\n\n\n/**\n * @param {ol.MapBrowserEvent} event Event.\n * @private\n */\n_ol_interaction_Draw_.prototype.createOrUpdateSketchPoint_ = function(event) {\n  var coordinates = event.coordinate.slice();\n  if (!this.sketchPoint_) {\n    this.sketchPoint_ = new _ol_Feature_(new _ol_geom_Point_(coordinates));\n    this.updateSketchFeatures_();\n  } else {\n    var sketchPointGeom = /** @type {ol.geom.Point} */ (this.sketchPoint_.getGeometry());\n    sketchPointGeom.setCoordinates(coordinates);\n  }\n};\n\n\n/**\n * Start the drawing.\n * @param {ol.MapBrowserEvent} event Event.\n * @private\n */\n_ol_interaction_Draw_.prototype.startDrawing_ = function(event) {\n  var start = event.coordinate;\n  this.finishCoordinate_ = start;\n  if (this.mode_ === _ol_interaction_Draw_.Mode_.POINT) {\n    this.sketchCoords_ = start.slice();\n  } else if (this.mode_ === _ol_interaction_Draw_.Mode_.POLYGON) {\n    this.sketchCoords_ = [[start.slice(), start.slice()]];\n    this.sketchLineCoords_ = this.sketchCoords_[0];\n  } else {\n    this.sketchCoords_ = [start.slice(), start.slice()];\n    if (this.mode_ === _ol_interaction_Draw_.Mode_.CIRCLE) {\n      this.sketchLineCoords_ = this.sketchCoords_;\n    }\n  }\n  if (this.sketchLineCoords_) {\n    this.sketchLine_ = new _ol_Feature_(\n        new _ol_geom_LineString_(this.sketchLineCoords_));\n  }\n  var geometry = this.geometryFunction_(this.sketchCoords_);\n  this.sketchFeature_ = new _ol_Feature_();\n  if (this.geometryName_) {\n    this.sketchFeature_.setGeometryName(this.geometryName_);\n  }\n  this.sketchFeature_.setGeometry(geometry);\n  this.updateSketchFeatures_();\n  this.dispatchEvent(new _ol_interaction_Draw_.Event(\n      _ol_interaction_DrawEventType_.DRAWSTART, this.sketchFeature_));\n};\n\n\n/**\n * Modify the drawing.\n * @param {ol.MapBrowserEvent} event Event.\n * @private\n */\n_ol_interaction_Draw_.prototype.modifyDrawing_ = function(event) {\n  var coordinate = event.coordinate;\n  var geometry = /** @type {ol.geom.SimpleGeometry} */ (this.sketchFeature_.getGeometry());\n  var coordinates, last;\n  if (this.mode_ === _ol_interaction_Draw_.Mode_.POINT) {\n    last = this.sketchCoords_;\n  } else if (this.mode_ === _ol_interaction_Draw_.Mode_.POLYGON) {\n    coordinates = this.sketchCoords_[0];\n    last = coordinates[coordinates.length - 1];\n    if (this.atFinish_(event)) {\n      // snap to finish\n      coordinate = this.finishCoordinate_.slice();\n    }\n  } else {\n    coordinates = this.sketchCoords_;\n    last = coordinates[coordinates.length - 1];\n  }\n  last[0] = coordinate[0];\n  last[1] = coordinate[1];\n  this.geometryFunction_(/** @type {!Array.<ol.Coordinate>} */ (this.sketchCoords_), geometry);\n  if (this.sketchPoint_) {\n    var sketchPointGeom = /** @type {ol.geom.Point} */ (this.sketchPoint_.getGeometry());\n    sketchPointGeom.setCoordinates(coordinate);\n  }\n  var sketchLineGeom;\n  if (geometry instanceof _ol_geom_Polygon_ &&\n      this.mode_ !== _ol_interaction_Draw_.Mode_.POLYGON) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new _ol_Feature_(new _ol_geom_LineString_(null));\n    }\n    var ring = geometry.getLinearRing(0);\n    sketchLineGeom = /** @type {ol.geom.LineString} */ (this.sketchLine_.getGeometry());\n    sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(), ring.getFlatCoordinates());\n  } else if (this.sketchLineCoords_) {\n    sketchLineGeom = /** @type {ol.geom.LineString} */ (this.sketchLine_.getGeometry());\n    sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n  }\n  this.updateSketchFeatures_();\n};\n\n\n/**\n * Add a new coordinate to the drawing.\n * @param {ol.MapBrowserEvent} event Event.\n * @private\n */\n_ol_interaction_Draw_.prototype.addToDrawing_ = function(event) {\n  var coordinate = event.coordinate;\n  var geometry = /** @type {ol.geom.SimpleGeometry} */ (this.sketchFeature_.getGeometry());\n  var done;\n  var coordinates;\n  if (this.mode_ === _ol_interaction_Draw_.Mode_.LINE_STRING) {\n    this.finishCoordinate_ = coordinate.slice();\n    coordinates = this.sketchCoords_;\n    if (coordinates.length >= this.maxPoints_) {\n      if (this.freehand_) {\n        coordinates.pop();\n      } else {\n        done = true;\n      }\n    }\n    coordinates.push(coordinate.slice());\n    this.geometryFunction_(coordinates, geometry);\n  } else if (this.mode_ === _ol_interaction_Draw_.Mode_.POLYGON) {\n    coordinates = this.sketchCoords_[0];\n    if (coordinates.length >= this.maxPoints_) {\n      if (this.freehand_) {\n        coordinates.pop();\n      } else {\n        done = true;\n      }\n    }\n    coordinates.push(coordinate.slice());\n    if (done) {\n      this.finishCoordinate_ = coordinates[0];\n    }\n    this.geometryFunction_(this.sketchCoords_, geometry);\n  }\n  this.updateSketchFeatures_();\n  if (done) {\n    this.finishDrawing();\n  }\n};\n\n\n/**\n * Remove last point of the feature currently being drawn.\n * @api\n */\n_ol_interaction_Draw_.prototype.removeLastPoint = function() {\n  if (!this.sketchFeature_) {\n    return;\n  }\n  var geometry = /** @type {ol.geom.SimpleGeometry} */ (this.sketchFeature_.getGeometry());\n  var coordinates, sketchLineGeom;\n  if (this.mode_ === _ol_interaction_Draw_.Mode_.LINE_STRING) {\n    coordinates = this.sketchCoords_;\n    coordinates.splice(-2, 1);\n    this.geometryFunction_(coordinates, geometry);\n    if (coordinates.length >= 2) {\n      this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n    }\n  } else if (this.mode_ === _ol_interaction_Draw_.Mode_.POLYGON) {\n    coordinates = this.sketchCoords_[0];\n    coordinates.splice(-2, 1);\n    sketchLineGeom = /** @type {ol.geom.LineString} */ (this.sketchLine_.getGeometry());\n    sketchLineGeom.setCoordinates(coordinates);\n    this.geometryFunction_(this.sketchCoords_, geometry);\n  }\n\n  if (coordinates.length === 0) {\n    this.finishCoordinate_ = null;\n  }\n\n  this.updateSketchFeatures_();\n};\n\n\n/**\n * Stop drawing and add the sketch feature to the target layer.\n * The {@link ol.interaction.DrawEventType.DRAWEND} event is dispatched before\n * inserting the feature.\n * @api\n */\n_ol_interaction_Draw_.prototype.finishDrawing = function() {\n  var sketchFeature = this.abortDrawing_();\n  var coordinates = this.sketchCoords_;\n  var geometry = /** @type {ol.geom.SimpleGeometry} */ (sketchFeature.getGeometry());\n  if (this.mode_ === _ol_interaction_Draw_.Mode_.LINE_STRING) {\n    // remove the redundant last point\n    coordinates.pop();\n    this.geometryFunction_(coordinates, geometry);\n  } else if (this.mode_ === _ol_interaction_Draw_.Mode_.POLYGON) {\n    // remove the redundant last point in ring\n    coordinates[0].pop();\n    this.geometryFunction_(coordinates, geometry);\n    coordinates = geometry.getCoordinates();\n  }\n\n  // cast multi-part geometries\n  if (this.type_ === _ol_geom_GeometryType_.MULTI_POINT) {\n    sketchFeature.setGeometry(new _ol_geom_MultiPoint_([coordinates]));\n  } else if (this.type_ === _ol_geom_GeometryType_.MULTI_LINE_STRING) {\n    sketchFeature.setGeometry(new _ol_geom_MultiLineString_([coordinates]));\n  } else if (this.type_ === _ol_geom_GeometryType_.MULTI_POLYGON) {\n    sketchFeature.setGeometry(new _ol_geom_MultiPolygon_([coordinates]));\n  }\n\n  // First dispatch event to allow full set up of feature\n  this.dispatchEvent(new _ol_interaction_Draw_.Event(\n      _ol_interaction_DrawEventType_.DRAWEND, sketchFeature));\n\n  // Then insert feature\n  if (this.features_) {\n    this.features_.push(sketchFeature);\n  }\n  if (this.source_) {\n    this.source_.addFeature(sketchFeature);\n  }\n};\n\n\n/**\n * Stop drawing without adding the sketch feature to the target layer.\n * @return {ol.Feature} The sketch feature (or null if none).\n * @private\n */\n_ol_interaction_Draw_.prototype.abortDrawing_ = function() {\n  this.finishCoordinate_ = null;\n  var sketchFeature = this.sketchFeature_;\n  if (sketchFeature) {\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n  }\n  return sketchFeature;\n};\n\n\n/**\n * Extend an existing geometry by adding additional points. This only works\n * on features with `LineString` geometries, where the interaction will\n * extend lines by adding points to the end of the coordinates array.\n * @param {!ol.Feature} feature Feature to be extended.\n * @api\n */\n_ol_interaction_Draw_.prototype.extend = function(feature) {\n  var geometry = feature.getGeometry();\n  var lineString = /** @type {ol.geom.LineString} */ (geometry);\n  this.sketchFeature_ = feature;\n  this.sketchCoords_ = lineString.getCoordinates();\n  var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n  this.finishCoordinate_ = last.slice();\n  this.sketchCoords_.push(last.slice());\n  this.updateSketchFeatures_();\n  this.dispatchEvent(new _ol_interaction_Draw_.Event(\n      _ol_interaction_DrawEventType_.DRAWSTART, this.sketchFeature_));\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_interaction_Draw_.prototype.shouldStopEvent = _ol_functions_.FALSE;\n\n\n/**\n * Redraw the sketch features.\n * @private\n */\n_ol_interaction_Draw_.prototype.updateSketchFeatures_ = function() {\n  var sketchFeatures = [];\n  if (this.sketchFeature_) {\n    sketchFeatures.push(this.sketchFeature_);\n  }\n  if (this.sketchLine_) {\n    sketchFeatures.push(this.sketchLine_);\n  }\n  if (this.sketchPoint_) {\n    sketchFeatures.push(this.sketchPoint_);\n  }\n  var overlaySource = this.overlay_.getSource();\n  overlaySource.clear(true);\n  overlaySource.addFeatures(sketchFeatures);\n};\n\n\n/**\n * @private\n */\n_ol_interaction_Draw_.prototype.updateState_ = function() {\n  var map = this.getMap();\n  var active = this.getActive();\n  if (!map || !active) {\n    this.abortDrawing_();\n  }\n  this.overlay_.setMap(active ? map : null);\n};\n\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of an\n * `ol.geom.Circle` geometry.\n * @param {number=} opt_sides Number of sides of the regular polygon. Default is\n *     32.\n * @param {number=} opt_angle Angle of the first point in radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {ol.DrawGeometryFunctionType} Function that draws a\n *     polygon.\n * @api\n */\n_ol_interaction_Draw_.createRegularPolygon = function(opt_sides, opt_angle) {\n  return (\n    /**\n         * @param {ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>} coordinates\n         * @param {ol.geom.SimpleGeometry=} opt_geometry\n         * @return {ol.geom.SimpleGeometry}\n         */\n    function(coordinates, opt_geometry) {\n      var center = coordinates[0];\n      var end = coordinates[1];\n      var radius = Math.sqrt(\n          _ol_coordinate_.squaredDistance(center, end));\n      var geometry = opt_geometry ? /** @type {ol.geom.Polygon} */ (opt_geometry) :\n        _ol_geom_Polygon_.fromCircle(new _ol_geom_Circle_(center), opt_sides);\n      var angle = opt_angle ? opt_angle :\n        Math.atan((end[1] - center[1]) / (end[0] - center[0]));\n      _ol_geom_Polygon_.makeRegular(geometry, center, radius, angle);\n      return geometry;\n    }\n  );\n};\n\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {ol.DrawGeometryFunctionType} Function that draws a box-shaped polygon.\n * @api\n */\n_ol_interaction_Draw_.createBox = function() {\n  return (\n    /**\n     * @param {Array.<ol.Coordinate>} coordinates\n     * @param {ol.geom.SimpleGeometry=} opt_geometry\n     * @return {ol.geom.SimpleGeometry}\n     */\n    function(coordinates, opt_geometry) {\n      var extent = _ol_extent_.boundingExtent(coordinates);\n      var geometry = opt_geometry || new _ol_geom_Polygon_(null);\n      geometry.setCoordinates([[\n        _ol_extent_.getBottomLeft(extent),\n        _ol_extent_.getBottomRight(extent),\n        _ol_extent_.getTopRight(extent),\n        _ol_extent_.getTopLeft(extent),\n        _ol_extent_.getBottomLeft(extent)\n      ]]);\n      return geometry;\n    }\n  );\n};\n\n\n/**\n * Get the drawing mode.  The mode for mult-part geometries is the same as for\n * their single-part cousins.\n * @param {ol.geom.GeometryType} type Geometry type.\n * @return {ol.interaction.Draw.Mode_} Drawing mode.\n * @private\n */\n_ol_interaction_Draw_.getMode_ = function(type) {\n  var mode;\n  if (type === _ol_geom_GeometryType_.POINT ||\n      type === _ol_geom_GeometryType_.MULTI_POINT) {\n    mode = _ol_interaction_Draw_.Mode_.POINT;\n  } else if (type === _ol_geom_GeometryType_.LINE_STRING ||\n      type === _ol_geom_GeometryType_.MULTI_LINE_STRING) {\n    mode = _ol_interaction_Draw_.Mode_.LINE_STRING;\n  } else if (type === _ol_geom_GeometryType_.POLYGON ||\n      type === _ol_geom_GeometryType_.MULTI_POLYGON) {\n    mode = _ol_interaction_Draw_.Mode_.POLYGON;\n  } else if (type === _ol_geom_GeometryType_.CIRCLE) {\n    mode = _ol_interaction_Draw_.Mode_.CIRCLE;\n  }\n  return /** @type {!ol.interaction.Draw.Mode_} */ (mode);\n};\n\n\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n * @private\n */\n_ol_interaction_Draw_.Mode_ = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  POLYGON: 'Polygon',\n  CIRCLE: 'Circle'\n};\n\n/**\n * @classdesc\n * Events emitted by {@link ol.interaction.Draw} instances are instances of\n * this type.\n *\n * @constructor\n * @extends {ol.events.Event}\n * @implements {oli.DrawEvent}\n * @param {ol.interaction.DrawEventType} type Type.\n * @param {ol.Feature} feature The feature drawn.\n */\n_ol_interaction_Draw_.Event = function(type, feature) {\n\n  _ol_events_Event_.call(this, type);\n\n  /**\n   * The feature being drawn.\n   * @type {ol.Feature}\n   * @api\n   */\n  this.feature = feature;\n\n};\n_ol_.inherits(_ol_interaction_Draw_.Event, _ol_events_Event_);\nexport default _ol_interaction_Draw_;\n","import _ol_ from '../index.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout.js';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype.js';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry.js';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {ol.Coordinate} center Center.\n * @param {number=} opt_radius Radius.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_Circle_ = function(center, opt_radius, opt_layout) {\n  _ol_geom_SimpleGeometry_.call(this);\n  var radius = opt_radius ? opt_radius : 0;\n  this.setCenterAndRadius(center, radius, opt_layout);\n};\n\n_ol_.inherits(_ol_geom_Circle_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.Circle} Clone.\n * @override\n * @api\n */\n_ol_geom_Circle_.prototype.clone = function() {\n  var circle = new _ol_geom_Circle_(null);\n  circle.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n  return circle;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Circle_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  var flatCoordinates = this.flatCoordinates;\n  var dx = x - flatCoordinates[0];\n  var dy = y - flatCoordinates[1];\n  var squaredDistance = dx * dx + dy * dy;\n  if (squaredDistance < minSquaredDistance) {\n    var i;\n    if (squaredDistance === 0) {\n      for (i = 0; i < this.stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n    } else {\n      var delta = this.getRadius() / Math.sqrt(squaredDistance);\n      closestPoint[0] = flatCoordinates[0] + delta * dx;\n      closestPoint[1] = flatCoordinates[1] + delta * dy;\n      for (i = 2; i < this.stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n    }\n    closestPoint.length = this.stride;\n    return squaredDistance;\n  } else {\n    return minSquaredDistance;\n  }\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Circle_.prototype.containsXY = function(x, y) {\n  var flatCoordinates = this.flatCoordinates;\n  var dx = x - flatCoordinates[0];\n  var dy = y - flatCoordinates[1];\n  return dx * dx + dy * dy <= this.getRadiusSquared_();\n};\n\n\n/**\n * Return the center of the circle as {@link ol.Coordinate coordinate}.\n * @return {ol.Coordinate} Center.\n * @api\n */\n_ol_geom_Circle_.prototype.getCenter = function() {\n  return this.flatCoordinates.slice(0, this.stride);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Circle_.prototype.computeExtent = function(extent) {\n  var flatCoordinates = this.flatCoordinates;\n  var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n  return _ol_extent_.createOrUpdate(\n      flatCoordinates[0] - radius, flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius, flatCoordinates[1] + radius,\n      extent);\n};\n\n\n/**\n * Return the radius of the circle.\n * @return {number} Radius.\n * @api\n */\n_ol_geom_Circle_.prototype.getRadius = function() {\n  return Math.sqrt(this.getRadiusSquared_());\n};\n\n\n/**\n * @private\n * @return {number} Radius squared.\n */\n_ol_geom_Circle_.prototype.getRadiusSquared_ = function() {\n  var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n  var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n  return dx * dx + dy * dy;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Circle_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.CIRCLE;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Circle_.prototype.intersectsExtent = function(extent) {\n  var circleExtent = this.getExtent();\n  if (_ol_extent_.intersects(extent, circleExtent)) {\n    var center = this.getCenter();\n\n    if (extent[0] <= center[0] && extent[2] >= center[0]) {\n      return true;\n    }\n    if (extent[1] <= center[1] && extent[3] >= center[1]) {\n      return true;\n    }\n\n    return _ol_extent_.forEachCorner(extent, this.intersectsCoordinate, this);\n  }\n  return false;\n\n};\n\n\n/**\n * Set the center of the circle as {@link ol.Coordinate coordinate}.\n * @param {ol.Coordinate} center Center.\n * @api\n */\n_ol_geom_Circle_.prototype.setCenter = function(center) {\n  var stride = this.stride;\n  var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n  var flatCoordinates = center.slice();\n  flatCoordinates[stride] = flatCoordinates[0] + radius;\n  var i;\n  for (i = 1; i < stride; ++i) {\n    flatCoordinates[stride + i] = center[i];\n  }\n  this.setFlatCoordinates(this.layout, flatCoordinates);\n};\n\n\n/**\n * Set the center (as {@link ol.Coordinate coordinate}) and the radius (as\n * number) of the circle.\n * @param {ol.Coordinate} center Center.\n * @param {number} radius Radius.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\n_ol_geom_Circle_.prototype.setCenterAndRadius = function(center, radius, opt_layout) {\n  if (!center) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null);\n  } else {\n    this.setLayout(opt_layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array.<number>} */\n    var flatCoordinates = this.flatCoordinates;\n    var offset = _ol_geom_flat_deflate_.coordinate(\n        flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    var i, ii;\n    for (i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Circle_.prototype.getCoordinates = function() {};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Circle_.prototype.setCoordinates = function(coordinates, opt_layout) {};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n */\n_ol_geom_Circle_.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.changed();\n};\n\n\n/**\n * Set the radius of the circle. The radius is in the units of the projection.\n * @param {number} radius Radius.\n * @api\n */\n_ol_geom_Circle_.prototype.setRadius = function(radius) {\n  this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n  this.changed();\n};\n\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {ol.ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link ol.proj.Projection} object.\n * @param {ol.ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link ol.proj.Projection} object.\n * @return {ol.geom.Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\n_ol_geom_Circle_.prototype.transform;\nexport default _ol_geom_Circle_;\n"],"sourceRoot":""}